<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:vue</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="vue-js">Vue.js</h1>
<h2 id="-">简介</h2>
<h4 id="-">基本介绍</h4>
<ul>
<li>Vue框架，是作者<strong>尤雨溪</strong>在google工作期间所研发并开源的</li>
<li>在初期主要了为了解决自身问题，后随着使用者的增多逐渐名气越来越大</li>
<li>促使Vue的持续发展，最终成为目前功能完善健壮的web开发框架，并足以支持起大型项目的开发</li>
<li>虽然Vue是开源项目，但大部分的工作仍由作者自己完成，工作量不言而喻</li>
<li>还好目前Vue得到了不少公司与个人的长期赞助，所以目前作者专职与Vue的开发，保证Vue的可持续发展</li>
</ul>
<h4 id="-">特点</h4>
<ul>
<li>Vue初期借鉴了很多来自AngularJS的语法，有AngularJS基础对于Vue的学习会比较轻松</li>
<li>相比其他MVVM框架，轻巧并且更容易上手</li>
<li>渐进式增强，可根据自己的需要逐步使用Vue生态圈提供的其他功能</li>
</ul>
<h4 id="-">官网与资源</h4>
<ul>
<li><a href="https://cn.vuejs.org">官网</a></li>
<li><a href="https://github.com/vuejs/vue">github</a></li>
</ul>
<h2 id="-">入门</h2>
<h4 id="vue-mvvm">Vue中的MVVM</h4>
<ul>
<li>Vue采用MVVM的设计模式进行代码的组织与编写</li>
<li>所以使用Vue开发通常会先在页面中创建一个Vue视图的根节点</li>
<li>然后创建一个Data数据对象，用于承载或声明Web应用所需的数据模型</li>
<li>最后创建一个Vue实例，该实例用于关联View与Data，处理业务逻辑<ul>
<li>创建Vue实例，需要一些配置项，其中el用来关联视图，data用来关联数据</li>
</ul>
</li>
</ul>
<h4 id="-">基本写法</h4>
<pre><code class="lang-html">&lt;body&gt;
    &lt;!-- 1. 视图编写 --&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 这里通过插值表达式语法可直接访问数据值，还可做一些其他运算 --&gt;
          &lt;p&gt;{{ test }}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 2. 数据模型
        var data = { test: &#39;Hello World&#39; };
        // 3. 视图模型
          var vm = new Vue({
              el: &#39;#app&#39;,
              data: data
          });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="-">插值表达式</h4>
<ul>
<li>语法：{{ 表达式 }}</li>
<li>表达式可以是data中声明的属性，或methods中声明的方法调用，或运算符运算</li>
<li>表达式不可以使用if、for、while等语句结构</li>
<li>表达式中还可以使用过滤器语法对值进行复杂处理</li>
<li>问题：页面可能出现闪烁插值表达式源码的情况，可配合v-cloak指令来解决</li>
</ul>
<h2 id="-">指令</h2>
<h4 id="-">简介</h4>
<ul>
<li>作用：DOM处理，数据渲染</li>
<li>特征：指令是带有v-前缀的特殊属性</li>
<li>语法：v-指令名称:指令参数.修饰符=&quot;表达式&quot;</li>
<li>特点：当数据变化时视图根据所用指令做出相应的变化</li>
</ul>
<h4 id="v-text">v-text</h4>
<ul>
<li>作用：更新元素的innerHtmltextContent<pre><code class="lang-html">&lt;!-- 这里的content是data数据模型中定义的属性 --&gt;
&lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt;
&lt;!--等同于下面--&gt;
&lt;span&gt;{{ content }}&lt;/span&gt;
</code></pre>
</li>
</ul>
<h4 id="v-html">v-html</h4>
<ul>
<li>作用：更新元素的innerHtml<pre><code class="lang-html">&lt;!-- 这里的content是data数据模型中定义的属性 --&gt;
&lt;span v-html=&quot;content&quot;&gt;&lt;/span&gt;
</code></pre>
</li>
</ul>
<h4 id="v-cloak">v-cloak</h4>
<ul>
<li>作用：在Vue渲染视图前隐藏元素，需要配合css样式才会生效</li>
<li>原理：vue在替换视图时会自动去除元素身上的v-cloak属性，好让元素显现出来<pre><code class="lang-html">&lt;!-- 这里的content是data数据模型中定义的属性 --&gt;
&lt;style&gt;
  [v-cloak] { display: none; }
&lt;/style&gt;
&lt;div v-cloak&gt;
  &lt;h2&gt;{{ title }}&lt;/h2&gt;
  &lt;article&gt;{{ content }}&lt;/article&gt;
&lt;/div&gt;
</code></pre>
</li>
</ul>
<h4 id="v-if">v-if</h4>
<ul>
<li>作用：控制元素的插入与删除<pre><code class="lang-html">&lt;!-- 这里的exists是data数据模型中定义的属性 --&gt;
&lt;div v-if=&quot;exists&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
</ul>
<h4 id="v-show">v-show</h4>
<ul>
<li>作用：控制元素的显示隐藏<pre><code class="lang-html">&lt;!-- 这里的isshow是data数据模型中定义的属性 --&gt;
&lt;div v-if=&quot;isshow&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
</ul>
<h4 id="v-for">v-for</h4>
<ul>
<li>作用：遍历数组或对象，也可指定遍历次数<pre><code class="lang-html">&lt;!--  遍历数组  --&gt;
&lt;ul&gt;
  &lt;li v-for=&quot;v in list&quot;&gt;{{ v }}&lt;/li&gt;
  &lt;li v-for=&quot;(v, i) in list&quot;&gt;{{ v }}_{{ i }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="lang-html">&lt;!--  遍历对象  --&gt;
&lt;ul&gt;
  &lt;li v-for=&quot;v in obj&quot;&gt;{{ v }}&lt;/li&gt;
  &lt;li v-for=&quot;(v, k) in obj&quot;&gt;{{ v }}_{{ k }}&lt;/li&gt;
  &lt;li v-for=&quot;(v, k, i) in obj&quot;&gt;{{ v }}_{{ k }}_{{ i }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="lang-html">&lt;!--  遍历指定次数，n从1开始，i从0开始  --&gt;
&lt;ul&gt;
  &lt;li v-for=&quot;n in 5&quot;&gt;{{ n }}&lt;/li&gt;
  &lt;li v-for=&quot;(n, i) in 5&quot;&gt;{{ n }}_{{ i }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
</ul>
<h4 id="v-show">v-show</h4>
<ul>
<li>作用：控制元素的显示隐藏<pre><code class="lang-html">&lt;!-- 这里的isshow是data数据模型中定义的属性 --&gt;
&lt;div v-if=&quot;isshow&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
</ul>
<h4 id="v-bind">v-bind</h4>
<ul>
<li>作用：动态设置属性值<pre><code class="lang-html">&lt;!-- 利用遍历得到的下标给li标签添加data-index自定义属性 --&gt;
&lt;ul&gt;
  &lt;li v-for=&quot;(v, i) in list&quot; v-bind:data-index=&quot;i&quot;&gt;{{ v }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 批量添加属性 --&gt;
&lt;p v-bind=&quot;{ &#39;data-id&#39;: obj.id, &#39;data-title&#39;: obj.title }&quot;&gt;{{ obj.content }}&lt;/p&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 单属性设置可使用简写形式 --&gt;
&lt;img :src=&quot;&#39;http://xxx.com&#39; + img.path&quot;&gt;&lt;/img&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 可通过.prop修饰符，指明Vue设置属性的方式由setAttribute转为普通方式 --&gt;
&lt;p :text-content=&quot;content&quot;&gt;&lt;/p&gt;
&lt;p :text-content.prop=&quot;content&quot;&gt;&lt;/p&gt;
</code></pre>
</li>
</ul>
<h4 id="v-on">v-on</h4>
<ul>
<li>作用：添加事件监听<pre><code class="lang-html">&lt;!-- 添加点击事件 --&gt;
&lt;button v-on:click=&quot;handle&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 可调用传参，可传入$event获取事件对象 --&gt;
&lt;button v-on:click=&quot;handle(true, $event, &#39;str&#39;)&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 批量事件绑定 --&gt;
&lt;button v-on=&quot;{ mousedown: handle1, mouseup: handle2 }&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 单事件绑定可使用简写形式 --&gt;
&lt;button @click=&quot;handle&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<pre><code class="lang-html">&lt;!-- 可通过.prevent修饰符阻止默认事件，stop阻止事件冒泡，once限制触发次数--&gt;
&lt;a @click.prevent.stop.once=&quot;handle&quot;&gt;按钮&lt;/a&gt;
</code></pre>
</li>
</ul>
<h4 id="v-model">v-model</h4>
<ul>
<li>作用：实现表单与data的双向绑定，view数据变化，model数据跟着变化，反之也一样</li>
<li>测试：可在控制台访问实例属性，并尝试修改属性，观察视图的变化<pre><code class="lang-html">&lt;!-- .trim修饰符作用是去除首尾空格，.number是数据自动转数字 --&gt;
&lt;form @submit.prevent&gt;
  &lt;input v-model.number=&quot;user_phone&quot; type=&quot;text&quot;&gt;&lt;/input&gt;
  &lt;input v-model.trim=&quot;user_pwd&quot; type=&quot;password&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
</li>
</ul>
<h4 id="v-once">v-once</h4>
<ul>
<li>作用：视图只渲染一次，后续不再变化，有助于优化性能<pre><code class="lang-html">&lt;footer v-once&gt;{{ about }}&lt;/footer&gt;
</code></pre>
</li>
</ul>
<h4 id="v-pre">v-pre</h4>
<ul>
<li>作用：跳过元素的编译，显示原始标签<pre><code class="lang-html">&lt;span v-pre&gt;{{ span }}&lt;/span&gt;
</code></pre>
</li>
</ul>
<h2 id="-">自定义指令</h2>
<h4 id="-">说明</h4>
<ul>
<li>作用：dom处理逻辑的封装</li>
<li>注意：使用时同样需要添加v-前缀</li>
<li>分类：全局指令与局部指令</li>
</ul>
<h4 id="-">定义</h4>
<ul>
<li>全局指令<ul>
<li><code>Vue.directive(name, config)</code></li>
<li>任何Vue实例所关联的视图中都可以使用</li>
</ul>
</li>
<li>局部指令<ul>
<li><code>new Vue({ directives: { name1: config, name2: config } })</code></li>
<li>只能在当前实例所关联的视图中使用</li>
</ul>
</li>
</ul>
<h4 id="-">配置项</h4>
<ul>
<li>bind<ul>
<li>指令与元素绑定时调用，只会调用一次</li>
</ul>
</li>
<li>inserted<ul>
<li>元素被插入到节点时调用，只会调用一次</li>
</ul>
</li>
<li>update<ul>
<li>元素或值更新时调用</li>
</ul>
</li>
<li>unbind<ul>
<li>所在元素卸载时调用，只会调用一次</li>
</ul>
</li>
</ul>
<h4 id="-">函数参数</h4>
<ul>
<li>定义指令时大部分是在bind与update时做操作</li>
<li>可以考虑使用简写方式，传递一个函数，在bind与update时调用</li>
<li>比如：<code>Vue.directive(name, fn)</code></li>
</ul>
<h4 id="-1">示例1</h4>
<pre><code class="lang-html">&lt;div id=&quot;app&quot;&gt;
    &lt;input v-focus type=&quot;text&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="lang-javascript">Vue.directive(&#39;focus&#39;, {
    inserted: function(el, binding, vnode, oldnode) {
        el.focus();
    }
});
</code></pre>
<h4 id="-2">示例2</h4>
<pre><code class="lang-html">&lt;div id=&quot;app&quot;&gt;
    &lt;p v-hint:strong=&quot;keyword&quot; v-html=&quot;content&quot;&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="lang-javascript">Vue.directive(&#39;hint&#39;, function(el, binding) {
    // 指令的参数配置标签名，值配置关键字
    let tag = binding.arg || &#39;i&#39;,
        keyword = binding.value;

    // 元素内的文本内容，及关键字匹配正则
    let text = el.textContent,
        reg = new RegExp(keyword, &#39;g&#39;);

    // 关键字加亮
    el.innerHTML = text.replace(reg, function(text) {
        let style = &#39;red&#39;;
        return `&lt;${tag} style=&quot;color: ${style}&quot;&gt;${text}&lt;/${tag}&gt;`;
    });
});
var vm = new Vue({
    el: &#39;#app&#39;,
    data: {
        keyword: &#39;我&#39;,
        content: &#39;我想让自己开心放轻松点，只可惜比我强的人从不这么想...&#39;
    }
});
</code></pre>
<h2 id="-">过滤器</h2>
<h4 id="-">说明</h4>
<ul>
<li>作用：项目中经常会对数据进行处理，可以把处理逻辑封装成过滤器使用</li>
<li>使用语法：{{ value | filter1 | filter2(arg1, arg2) | ... }}</li>
<li>注意：只能在插值表达式中使用</li>
<li>分类：全局过滤器与局部过滤器</li>
</ul>
<h4 id="-">定义</h4>
<ul>
<li>全局过滤器<ul>
<li><code>Vue.filter(name, fn)</code></li>
<li>任何Vue实例所关联的视图中都可以使用</li>
</ul>
</li>
<li>局部过滤器<ul>
<li><code>new Vue({ filters: { name1: fn, name2: fn } })</code></li>
<li>只能在当前实例所关联的视图中使用</li>
</ul>
</li>
</ul>
<h4 id="-">示例</h4>
<pre><code class="lang-html">&lt;span&gt;{{ time | formatDate }}&lt;/span&gt;
</code></pre>
<pre><code class="lang-javascript">Vue.filter(&#39;formatDate&#39;, function(time) {
    let date = new Date(time);
    return `${ date.getFullYear() }-${ date.getMonth() + 1 }-${ date.getDate() }`;
});
</code></pre>
<h2 id="computed">computed</h2>
<h4 id="-">说明</h4>
<ul>
<li>如果一个属性的值受其他值的影响，那么可以把这个属性定义为计算属性</li>
<li>这里定义的属性不能在data里重复定义</li>
</ul>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var vm = new Vue({
    el: &#39;#app&#39;,
    data: { 
        price: 0,
        number: 0,
    },
    computed: {
        // 总价是由单价与数量动态决定的
        total: function() {
            this.total = this.price * this.number;
        }
    }
});
</code></pre>
<h2 id="watch">watch</h2>
<h4 id="-">说明</h4>
<ul>
<li>监听值某个值的变化，然后做出响应</li>
<li>watch相比beforeUpdate与updated生命周期函数更具有针对性</li>
</ul>
<h4 id="-">示例</h4>
<pre><code class="lang-javascript">var vm = new Vue({
    el: &#39;#app&#39;,
    data: { 
        price: 0,
        number: 0,
    },
    computed: {
        // 总价是由单价与数量动态决定的
        total: function() {
            this.total = this.price * this.number;
        }
    },
    watch: {
        // 当总价变化时，发出消息通知
        total: function(newV, oldV) {
            this.$emit(&#39;totalchange&#39;, newV, oldV);
        }
    }
});
</code></pre>
<h2 id="-">组件</h2>
<h4 id="-">简介</h4>
<ul>
<li>代码复用是软件开发不可避免的一个话题</li>
<li>函数、对象、插件、模块都是复用的表现形式</li>
<li>在web前端领域，WebComponents提供了一种新的思路，自定义标签</li>
<li>一个自定义标签拥有自己的模版、样式、脚本，并实现一个完成功能</li>
<li>这有点类似于浏览器内置的select、radio、checkbox组件</li>
<li>vue便提供了类似的组件系统</li>
</ul>
<h4 id="-">定义</h4>
<h6 id="-">一步到位</h6>
<ul>
<li>全局组件：<code>Vue.component(组件名, 配置)</code></li>
<li>局部组件：<code>new Vue({ components: { 组件名1: 配置，组件名2：配置 } })</code></li>
</ul>
<h6 id="-">标准步骤</h6>
<ul>
<li>先获取组件构造函数：<code>var  com = Vue.extend(配置)</code><ul>
<li>然后单独注册为全局组件：<code>Vue.component(组件名, com)</code></li>
<li>注册局部组件：<code>new Vue({ components: { 组件名1: com } })</code></li>
</ul>
</li>
</ul>
<h6 id="-">注意事项</h6>
<ul>
<li>template对应的模版必须使用一个根元素包裹起来</li>
<li>data必须为一个函数，内部返回一个对象</li>
<li>在需要切换组件的地方使用一对component标签</li>
</ul>
<h2 id="-">动态组件</h2>
<h4 id="-">说明</h4>
<ul>
<li>作用：根据条件在某个地方动态切换组件，以显示不同的效果<ul>
<li>比如Tab栏，点击导航按钮切换不同的组件，显示不一样的效果</li>
<li>比如单页面应用，根据url的变化，切换不同的页面</li>
</ul>
</li>
<li>实现：该需求可以通过v-if指令来实现，但是官网提供了更便捷的实现方式</li>
<li>语法：<code>&lt;component :is=&quot;组件名称&quot;&gt;&lt;/component&gt;</code></li>
</ul>
<h4 id="-">示例</h4>
<pre><code class="lang-html">&lt;div id=&quot;app&quot;&gt;
    &lt;component v-bind:is=&quot;pageName&quot;&gt;&lt;/component&gt;
    &lt;button @click=&quot;pageName=&#39;v-login&#39;&quot;&gt;登陆&lt;/button&gt;
    &lt;button @click=&quot;pageName=&#39;v-register&#39;&quot;&gt;注册&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="lang-javascript">var vm = new Vue({
    el: &#39;#app&#39;,
    data: {
        &#39;pageName&#39;: &#39;v-login&#39;
    },
    components: {
        // 登陆组件
        &#39;v-login&#39;: {
            template: &#39;&lt;h1&gt;登陆&lt;/h1&gt;&#39;,
        },
        // 注册组件
        v-register&#39;: {
            template: &#39;&lt;h1&gt;注册&lt;/h1&gt;&#39;,
        }
    }
});
</code></pre>
<h2 id="-">组件父子数据传递</h2>
<h4 id="-">数据父传子</h4>
<ul>
<li>在引入组件的标签上，通过自定义属性绑定来自父的数据</li>
<li>在子组件中通过props来配置需要获取标签的那些属性值</li>
<li>只要父定义，子配置，那么子就可以使用数据了</li>
</ul>
<h4 id="-">数据子传父</h4>
<ul>
<li>在需要的时候子通过this.$emit(eventName, data)发送消息与数据</li>
<li>父在引入子组件的标签上，通过v-on:eventName=&quot;事件回调&quot;，来获取消息与数据</li>
<li>只要子发送，父监听，那么父就可以使用来自子的数据</li>
</ul>
<h2 id="-">生命周期函数</h2>
<h4 id="-">说明</h4>
<ul>
<li>vue在内部的执行流程中，提供了相对应的生命周期函数配置接口</li>
<li>如果配置了这些函数，那么它们会在恰当的时机被vue自动调用</li>
</ul>
<h4 id="-">生命周期函数</h4>
<ul>
<li>beforeCreate<ul>
<li>刚初始化好实例，还未进行数据观察、事件绑定</li>
<li>可以认为vm部分已准备好</li>
</ul>
</li>
<li>created<ul>
<li>实例已准备好，还未进行模版的编译解析</li>
<li>可以认为vm、m部分已准备好</li>
</ul>
</li>
<li>beforeMount<ul>
<li>模版已编译好，还未插入到页面中</li>
<li>可以认为vm、m、v都已准备好</li>
</ul>
</li>
<li>mounted<ul>
<li>模版已插入页面</li>
<li>可以认为项目跑起来了</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>修改数据，但视图还没重新渲染</li>
</ul>
</li>
<li>updated<ul>
<li>视图已重新渲染</li>
</ul>
</li>
<li>beforeDestroy<ul>
<li>实例销毁前，什么都没有做</li>
</ul>
</li>
<li>destroyed<ul>
<li>实例销毁后，所有绑定都解除，子实例也被销毁</li>
</ul>
</li>
</ul>
<h2 id="-">过渡动画</h2>
<h4 id="-">说明</h4>
<ul>
<li>vue框架本身并没有提供任何样式和动画效果</li>
<li>vue过渡系统仅仅提供了方便我们加入动画效果的接口</li>
<li>具体的动画效果还需要我们自己去写</li>
</ul>
<h4 id="-">使用</h4>
<ul>
<li>首先使用transition标签把要过渡的元素包起来</li>
<li>包起来后vue会检测那些元素设置了trasnsition或者animation样式</li>
<li>如果设置了，那么vue会在这个元素显式隐藏的生命周期中对元素进行一些处理<ul>
<li>添加对应的生命周期class</li>
<li>提供对应的生命周期函数</li>
</ul>
</li>
</ul>
<h4 id="-">生命周期</h4>
<ul>
<li>注意：这些样式只在元素显示隐藏的生命周期中有效</li>
<li>.xx-enter<ul>
<li>在元素显示前，设置动画的初始值</li>
</ul>
</li>
<li>.xx-enter-to<ul>
<li>元素显示后，动画运行的最终值</li>
</ul>
</li>
<li>.xx-leave<ul>
<li>在元素隐藏前，设置动画的初始值</li>
</ul>
</li>
<li>.xx-leave-to<ul>
<li>元素隐藏后，动画运行的最终值</li>
</ul>
</li>
</ul>
<h2 id="vue-cli">vue-cli</h2>
<h4 id="-">说明</h4>
<ul>
<li>Vue官网提供的脚手架生成器，可帮我们自动搭建开发环境</li>
<li>vue-cli中提供了5种不同的脚手架供我们选择</li>
</ul>
<h4 id="-">脚手架分类</h4>
<ul>
<li>webpack<ul>
<li>基于webpack的开发环境，集成了代码检查、测试、热部署等功能</li>
</ul>
</li>
<li>webpack-simple<ul>
<li>基于webpack的简单版开发环境</li>
</ul>
</li>
<li>browerify<ul>
<li>基于browerify的开发环境，集成了代码检查、测试、热部署等功能</li>
</ul>
</li>
<li>browerify-simple<ul>
<li>基于browerify的简单版开发环境</li>
</ul>
</li>
<li>simple<ul>
<li>只提供解析.vue文件的普通开发环境</li>
</ul>
</li>
</ul>
<h4 id="-">工具安装</h4>
<ul>
<li>全局安装：<code>npm install -g vue-cli</code></li>
<li>测试：<code>vue --version</code></li>
</ul>
<h4 id="webpack-">webpack脚手架使用</h4>
<ul>
<li>生成脚手架<ul>
<li><code>vue init webpack ${ 项目名称 }</code></li>
</ul>
</li>
<li>安装项目依赖<ul>
<li><code>cd ${ 项目名称 }</code></li>
<li><code>npm install</code></li>
</ul>
</li>
<li>启动开发模式<ul>
<li>npm run dev</li>
</ul>
</li>
<li>代码编译<ul>
<li>npm run build</li>
</ul>
</li>
</ul>
<h4 id="-">项目结构说明</h4>
<ul>
<li>build<ul>
<li>webpack相关配置与脚本</li>
</ul>
</li>
<li>config<ul>
<li>配置文件，主要用于区分开发环境、测试环境、线上环境</li>
</ul>
</li>
<li>src<ul>
<li>项目源码及引用的资源</li>
</ul>
</li>
<li>static<ul>
<li>不需要webpack处理的静态资源</li>
</ul>
</li>
<li>test<ul>
<li>测试脚本</li>
</ul>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>